package cn.wjb114514.Facade;

/**
 * 外观模式：
 * 需求：有一个家庭影院项目，，要求有DVD播放器，投影仪，自动屏幕，环绕立体声。 ...
 * 我们手上有很多遥控器： 开爆米花机，放屏幕，开投影仪，开音响....
 *
 * 传统方式 Client ---> DVDPlayer[open() close() set() ...] , Projector, Stereo ...
 * 即客户端直接依赖这些设备类。
 * 问题：client里需要创建这些设备的对象，并调用这些方法，操作混乱
 *      2. 一个设备维护，client要较大修改
 *   修改：定义一个高层接口，给子系统的一组接口提供一个一致的界面，
 *   也就是说：通过定义一个一致的接口（界面类） 用以屏蔽内部子系统 的细节（不对Client暴露，也就是说我们client再也不用手动创建这些子系统对象，然后手动操作这些对象方法）
 *   ==> 外观模式
 *
 *   外观模式Facade[也叫 过程模式]
 *   为子系统的一组接口，提供一个一致的界面类，此模式定义一个高层接口，这个接口使得子系统更加容易使用[结构性]
 *   外观模式通过定义一个一致的接口，用于屏蔽内部子系统的细节，使得调用端只需要依赖这个接口，不需要依赖其下面的子系统~
 *
 *   外观模式解决了 子系统接口的复杂的调用，类似一键装机接口，我们不需要手动安装各个子部件，直接依赖一键装机，就可以获得各种软件，比如lol，cf...
 *
 *   外观模式：
 *   外观模式对外屏蔽了子系统的细节，因此外观模式降低了 对子系统使用的复杂度
 *   外观模式对客户端和子系统的耦合关系，让子系统内部模块更易于维护和扩展
 *   合理的外观模式 可以更好划分访问层次
 *
 *   系统需要进行分层[这里应该是横向的层次，也就是各个子系统(模块)]设计时，可以采取外观模式
 *   维护一个遗留的大型系统：这个系统已经变得非常难以维护和扩展。
 *   此时可以考虑开发一个facade类，来提供遗留系统比较清晰的简单接口，让系统 与facade类交互。提高复用性
 *   使用外观模式要让系统有层次[各个横向子系统有比较明显的纵向调用关系，有层次的调用，比如看电影是有层次的，有序的，得先打开dvd，投影仪再看... 类似关键路径，和源文件的依赖关系，这些都是有层次的事件]，
 *   如果层次体现的不是很明显，也就是说A的a1方法和B的b1方法之间没有特别明显的先后顺序，而且类很少的情况下，可以直接调用模块，不采取外观模式！
 *
 *   所谓外观模式 就是在 Client和各子系统之间又加了一层[页面层]，所以语言的精髓就是包装，分层....
 *   前提是子系统之间的功能调度是比较有层次的，有序的，
 *
 */
public class Start {
}
