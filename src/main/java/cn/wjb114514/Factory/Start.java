package cn.wjb114514.Factory;

import java.util.Calendar;

/**
 * 项目需求：披萨定制
 * 要求披萨的种类便于扩展，便于维护
 * 1.披萨的种类很多
 * 2.披萨的制作有四步
 * 3.完成订购功能
 *
 * 传统模型：易于理解，但是破坏了ocp原则
 * 比如我们增加一种披萨。需要在orderPizza[创建pizza的代码]里增加if判断语句
 * 简单工厂模式：把创建Pizza对象封装在一个类里，这样我们有新的Pizza种类是，只需要修改该类即可，那么创建Pizza对象的代码就不需要修改了
 *
 * 基本介绍：简单工厂模式属于创建型模式，是工厂模式的一种。
 * 1.简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。
 * 2.定义了一个创建对象的类，由这个类来封装实例化对象的行为
 * 3.开发过程中：当我们需要用到大量的创建某种，某类或者某批对象时，就会用到工厂模式。
 * 具体的创建细节会被工厂对象封装
 * 核心：创建对象的类不和实例类有依赖，不然实体类有变化，创建对象的类也跟着变。
 * 而是把创建对象的类和一个简单工厂关联，这样实体类有变化，只需要修改工厂代码
 * 因为创建对象的类可能有很多，所以我们用一个工厂和这些创建对象的类聚合起来
 *
 * 简单工厂模式，也叫静态工厂模式：
 * 把创建方法改为静态方法，可以改进~
 * 使用静态工厂模式的方法，直接new就可以，不用传入一个工厂对象
 * 当然不用静态方法，传入工厂对象可以实现工厂的定制化。比如有什么业务逻辑就创建一个相关的工厂类，然后new出工厂对象实现不同的功能
 *
 *
 * 2.工厂方法模式
 * 新的需求：用户点pizza时，可以选择不同的口味（北京的，上海的...）。
 * 解决方式：北京的工厂类，上海的工厂类... 这样我们的工厂类就很多
 * 设计模式:工厂方法模式 将工厂类里创建对象的方法，抽象为抽象方法，具体的创建方法由子类实现。
 * 将对象的实例化方法推迟到子类
 */
public class Start {
    public static void main(String[] args) {
        // new OrderPizza2();
        Calendar calendar = Calendar.getInstance();
    }
}
