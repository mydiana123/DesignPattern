package cn.wjb114514.FlyWeight;

/**
 * 享元模式：
 * 需求 网站项目
 * 网站的形式有很多种：新闻，博客，微信公众号
 * 网站的基本形式一致，但是具体发布的内容不同，
 * 方案一：  直接复制+修改，为用户B，C,D分配一个虚拟空间，建立B,C,D的网站
 * 问题：网站结构的相似量很高，对于访问量不是很高的网站，对资源的耗费较大
 * 解决：整合到同一个网站中，共享相关的代码和数据，对于硬盘，CPU，内存，数据库空间等，资源都可以共享
 * 享元模式：flyweight pattern / 蝇量模式
 * 运用共享技术有效地支持大量 [细粒度]的对象
 * 常用于系统底层开发：数据库连接池，里面都是创建好的 对象。如果有就直接拿，没有则创建。
 * 享元模式可以解决[重复对象的浪费问题]，当系统中有大量的[相似对象]，需要缓冲池里，不需要总是创建新对象，可以从缓冲池里拿。可以降低系统内存，提高效率
 * 经典应用：池技术 ==> 字符串常量池 数据库连接池，缓冲池
 * 方案二：
 *
 * 特点：工厂[池] 对细粒度[轻量级对象]中的稳定状态进行缓存，不稳定状态不缓存，用户自行提供
 * 有点类似volatile关键字，缓存的实质就是对不变的状态的保存，以便下一次调用，而对于易变的状态，自然就别缓存了。
 * 你既然易变了，缓存也没意义，就算把状态A缓存了，马上就变成状态B。
 * 因此volatile关键字就是说：我这个对象很易变，所以不要轻易地使用CPU缓存来缓存我，给自己找不自在~
 */
public class Start {
}

/*
总结：
1.享元模式，享==共享 元==对象
2.系统中的大量对象可复用时[比如黑棋子和白棋子对象，给谁用都是这俩对象，变不了] 就可以使用享元
3.用唯一标识码判断对象[比如网站需求里，唯一标识码就是网站的类型，用hashMap存储，唯一标识码就作为key]
4.享元模式提高了系统复杂度，对程序员：需要判断出哪个是内部 哪个是外部，而且外部对象需要自己创建，不可以被缓存，内部对象无需自己创建，可以被缓存
5.享元模式的经典就是 工厂类，工厂类用于存放 细粒度对象的内部状态。进行缓存
6.享元模式主要用于 xxx连接池 xxx常量池。
 */