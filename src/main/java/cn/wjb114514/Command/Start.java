package cn.wjb114514.Command;

/**
 * 设计模式：命令模式
 * 1.智能生活项目需求
 * 我们买了一些家电， 照明灯，风扇，冰箱，洗衣机、
 * 这些智能家电来自不同厂商，我们 不想针对每个家电都安装一个app进行控制，
 * 我们希望能有一个统一的app控制全部的智能家电。
 *
 * 需求：各个智能家电厂商 都要提供一个统一的接口，给最终的app调用，这时 就可以采取命令模式
 *
 * 命令模式 : 把动作的请求者 和 动作执行者 解耦，并通过命令把二者关联。
 *
 * 命令模式 ==>
 * 1.在软件设计中，我们经常需要向某些对象发送请求，但是不知道请求的接受者是谁 [将军 大喊 "10个士兵进攻" 于是10个士兵进行了进攻] 也不知道被请求的操作是哪个
 * 我们只需要在程序运行时 指定具体的请求接受者，这个指定请求接受者的工作，也不由请求发起者进行，也就是请求的发起者和接受者是解耦的
 * 2.我们把 请求封装为一个对象，以便使用不同的参数表示不同的请求[命令] ==> 发起者不知道请求的操作具体是哪个，这个过程对请求发起者是隐蔽的。
 * 同时命令模式 支持可撤销的功能。
 * 3.将军[命令发布者] 士兵[命令的具体执行者] 命令[连接了将军和士兵]
 * 几个角色：Invoker [命令发布者，调用者] Receiver[被调用者/士兵] MyCommand[命令，实现Command接口，内部持有接收对象]
 *
 *
 * 总结：
 * 1.将发起请求的对象与 执行请求的对象进行解耦 发起请求的对象为调用者，调用者只需要调用命令对象的execute方法，就可以使得接受者完成命令执行的方法。
 * [!而不必知道 接受者是谁，接受者咋实现的命令执行，相当于命令对象把接受者以及其具体执行方法进行了封装，不对外暴露] 命令模式起到了桥梁作用
 * 2.容易设计一个 [命令队列]，只需要把命令对象放入队列里，就可以多线程执行命令。 [!这种设计模式在各大设计模式里都有体现，原理就是ocp。即子类添加只需要操作集合，不需要修改源码]
 * 3.容易实现对请求的撤销和重做
 *
 * 不足：容易导致某个系统有过多具体的命令类 [打开TV命令，关闭TV命令，调大TV声音命令... 都需要继承一个Command]
 * 4.空命令也是一种设计模式，省去了判空操作 [如果按钮没有操作，我们不是给其赋值为null。如果真赋值为null了，为了避免空指针，每次按下按钮都要判断是不是为空]
 * 但是我们初始化为一个空操作，就算真的按到了空按钮，也不会报错
 * 6.应用场景：页面的一个按钮就是一个命令[初衷] ==> 模拟CMD命令，订单的撤销/恢复 触发/反馈机制 （按下按钮就会导致一个操作被执行。有点类似回调函数。）
 *
 *
 *
 */
public class Start {
}
