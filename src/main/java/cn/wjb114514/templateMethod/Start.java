package cn.wjb114514.templateMethod;

/**
 * 需求：制作豆浆
 * 选材 ===> 添加配料 ===> 浸泡 ===> 放入豆浆机打碎
 * 只有添加配料这一步 因人而异，其他大同小异，所以只需要针对添加配料做文章
 *
 *  模板方法模式：
 *  1.在一个抽象类公开定义了 执行它的方法的模板 [比如上例中的 四步骤，做成四个抽象方法]
 *  2.某些步骤【也就是因人而异的步骤】具体实现由子类完成，使得子类 [!不改变一个算法的骨架，就可以重定义算法的结构]
 *
 *
 *
 *  1.基本思想：算法只存在于一个地方，也就是在父类中，容易修改。 需要修改算法时，只需要修改父类的模板方法 或者已经实现的某 些步骤 子类就会继承这些修改
 *  [可以看到继承的好处，虽然增加了耦合性，但是父类的修改会被子类继承，这样修改多个，就变为修改一个]
 *  2.实现了代码最大化的复用，父类的模板方法和 [已经实现的某些步骤] 会被子类直接继承使用
 *  3.即统一了算法，也提供了很大的灵活性，父类的模板方法确保了 算法结构的不变。[同时由子类提供部分步骤的实现]
 *  4.不足之处：每一个不同的实现都要一个子类。 会使系统庞大
 *  5.模板方法会加一个final，防止子类重写而导致 算法结构被误修改
 *  6.使用场景：当要完成某个过程，这些步骤基本相同，但是在各别步骤的实现有所不同。
 *
 *  或者统计某段代码执行的时间
    模板方法 1.记录执行前时间 2.执行方法[由子类实现] 3.记录执行后时间 4.打印执行时间。

 模板方法模式和 外观模式 有一些相似之处，但是模板方法模式是行为设计模式，而外观模式是结构设计模式
 两者都是把一系列步骤进行组合，规范，但是模板方法对于一个业务逻辑的处理，基本都是一样的，而外观模式可以随着子系统组合的多样性，完成多样的业务逻辑组合。
 *
 */
public class Start {
}
