package cn.wjb114514.bridge;

import com.mysql.jdbc.Driver;

import java.sql.DriverManager;

/**
 * 桥接模式
 * 对不同手机类型，完成操作：开机 关机 上网 打电话等
 * 传统方式：
 *                                         Phone（interface）
 *                                            实现
 *                              手机类型A      手机类型B        手机类型C
 *                            A的子类型A1，A2  B的子类型B1，b2..   C1 C2..
 * ABC指的是大类型，比如翻盖的手机，折叠手机，智能手机。
 * 这样如果增加一个手机，比如苹果手机。就需要设计A3=翻盖苹果手机 B3=折叠苹果手机 C3=智能苹果手机
 * 很不方便，违反单一原则，造成类爆炸
 * 桥接模式的目的 是为了把二维的问题转换为 一维+一维的问题，原本是基于两层泛化的模型，修正为 一层泛化+聚合抽象+抽象修正，即抽象层[abstraction]聚合实现层实现子类[concreteImplementor]，同时修正层[refinedAbstraction]继承抽象层，完成功能二次扩展。
 * 桥接模式：
 * 将实现与抽象 放到两个不同的类层次里，使两个层次可以独立改变
 * 是一种结构型设计模式
 * 基于类的最小设计原则，即增加功能扩展功能时，尽量增加最少的类。具体方式就是 用组合和集合以及继承等行为，让类承担不同的职责、
 * 主要特点是把抽象与行为实现分离，从而保持 各部分的独立性以及功能扩展
 *
 * 桥接模式 是为了解决二维关系中类爆炸的问题
 * 比如一支铅笔，有两个属性（二维） 分别是 种类和颜色。
 * 那么如果把铅笔定义为抽象，abstract class Pencil。 分别有三个种类(2B HB 自动铅) 和 10种颜色
 * 而如果我们一味地通过继承完成功能的扩展（给铅笔添加样式，颜色） 这样就需要30个类来完成所有样式的铅笔。
 * 而如果我们把抽象和实现分离，即铅笔的种类和颜色之间是聚合关系。
 * 即我们只把铅笔的颜色认为是铅笔的属性，化二维为一位。
 * 我们定义一个 实现层Color，其实现类定义了铅笔的颜色信息 （10个颜色类） class Red Purple ...
 * 我们定义一个抽象层 Pencil。其内部聚合了铅笔的实现层，现在我们就有 10种Color的Pencil了。
 * 对于样式，我们认为是抽象层的再细化，也就是refined。
 * 我们定义一个 2B HB 自动铅 的类，继承抽象层，对抽象层的方法进一步修正，
 * 这样 我们就有了3个 修正的抽象类。
 * 修正抽象类 通过修正抽象层 的方法，调用实现子类的方法，可以看到，抽象层 方法的功能，实际上是被修正抽象层和实现层子类共同增强了。
 * 所以抽象层起到了 桥接（bridge） 抽象修正层（RefinedAbstraction） 和 实现层子类（ConcreteImplementor）的作用。
 * 化乘法为加法： 3*10 = 30 3+10=13 大大减少了类爆炸的风险
 *
 *
 *
 *
 * 其实jdbc并没有体现我们说的桥接模式，即二维问题转为 一维问题。
 * 但是jdbc的设计遵循了桥接模式的原则，即实现和抽象分离。
 * 也就是抽象层是java设计者 制定的接口。
 * 实现层是各数据库厂商的接口实现类（第三方jar包）
 * 程序员只需要使用java接口，而不关心厂商是怎么实现的。体现了 桥接模式，设计模式的具体实现和 我们的桥接模式还不太一样~ 但是理念是一样的。
 *
 * 抽象层DriverManager 内部聚合了 实现层Driver的对象集合。 达成了抽象和实现的分离。
 */
public class Start {

}
