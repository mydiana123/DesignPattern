package cn.wjb114514.iterator;

import java.util.Iterator;

// 注意：设计模式的设计，主要是为了完成六大基本原则，其中ocp，单一职责，依赖倒转 等原则，在几个设计模式里频频出现。
// 而单一职责原则 在多个设计模式里都有涉及，我们就是要在学习设计模式的过程中，体会这些原则的使用，不要死记硬背设计模式
/**
 * 需求：遍历 组合模式描述的 学校-学院-系模型
 * 传统做法：
 *
 *          学校
 *          学院
 *          系
 *
 *          问题：学校内部可能用数组 管理其下的学院， 而学院内部可能用HashMap存储数据...
 *          解决方案 ==> 迭代器模式
 *
 *  迭代器模式：行为模式
 *  如果我们的集合元素使用不同方式实现。针对这些不同的集合元素，就要采取多种遍历方式。而且还会暴露元素的内部结构[客户端使用jdk原生的操作集合/数组的方式，可以让用户得知存储元素的内部细节]
 *  迭代器模式： 提供一种遍历集合元素的 [统一接口] 客户端只管调用此接口，得到数据，不用管数据底层究竟被存放到了什么结构中：即不暴露内部结构
 *
 *
 * 注意事项：
 * 优点 ==> 提供一个统一的方法遍历对象，客户不用考虑聚合的类型，使用一种方法就可以遍历对象
 * 隐藏了聚合的内部结构，客户端要遍历集合 时，只能取到迭代器，而不知道聚合的具体组成
 * 提供了一种设计思想， 一个类[应该只有一个引起变化的原因] ==> 单一职责
 * 在聚合中，我们把迭代器分开，就是要把管理对象集合[聚合对象] 和 遍历对象集合[迭代器]的责任分开、
 * 注意：好多种设计模式都体现了这种思想
 * 访问者模式 ==> 把数据结构 和 对数据结构的操作分开 即一个数据结构，理应只负责管理具体的元素结构，而不负责对元素结构的操作
 * 命令模式 ==> 把命令发布者 和 命令执行者解耦： 即命令发布者不应该知道 命令执行者是如何操作的
 * 迭代器模式 ==> 把集合元素的存储 和 遍历分开，也就是说，用户遍历集合时，不应该知道集合是怎么存储的
 *
 * 这种单一职责， 使得 集合元素如果需要修改存储，只需要修改负责存储的代码，而需要修改遍历方式，只需要修改迭代器的代码
 * 如果二者混杂，耦合性大，修改时互相影响，导致 很难维护~
 *
 * 当需要展示一组相似对象，或者遍历同一组相同对象时，使用迭代器模式
 *
 * 缺点：每个聚合对象都要一个迭代器，多个迭代器类不好管理
 * 所以可以看到 ArrayList这种 聚合对象，直接把迭代器类做成 私有的内部类，因为这种迭代器类大多数是无需修改的..
 *
 */
public class Start {
    public static void main(String[] args) {

    }
}
